package com.example;// Generated by Numerix on 05/18/2018 datasync

import com.github.benmanes.caffeine.cache.CacheWriter;
import com.github.benmanes.caffeine.cache.RemovalCause;

import java.util.AbstractMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import io.reactivex.subjects.PublishSubject;

public final class RxCacheWriter<K, V> implements CacheWriter<K, V> {
    private final PublishSubject<Map.Entry<K, V>> subject;

    private RxCacheWriter(Builder<K, V> builder) {
        subject = PublishSubject.create();
        subject.buffer(builder.bufferTimeNanos, TimeUnit.NANOSECONDS)
                .map(entries -> entries.stream().filter(Objects::nonNull).collect(
                        Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, builder.coalescer)))
                .subscribe(builder.writeAction::accept);
    }

    @Override
    public void write(K key, V value) {
        subject.onNext(new AbstractMap.SimpleImmutableEntry<>(key, value));
    }

    @Override
    public void delete(K key, V value, RemovalCause removalCause) {}

    public static final class Builder<K, V> {
        private Consumer<Map<K, V>> writeAction;
        private BinaryOperator<V> coalescer;
        private long bufferTimeNanos;

        /**
         * The duration that the calls to the cache should be buffered before calling the
         * <code>writeAction</code>.
         */
        public Builder<K, V> bufferTime(long duration, TimeUnit unit) {
            this.bufferTimeNanos = TimeUnit.NANOSECONDS.convert(duration, unit);
            return this;
        }

        /** The callback to perform the writing to the database or repository. */
        public Builder<K, V> writeAction(Consumer<Map<K, V>> writeAction) {
            this.writeAction = Objects.requireNonNull(writeAction);
            return this;
        }

        /** The action that decides which value to take in case a key was updated multiple times. */
        public Builder<K, V> coalesce(BinaryOperator<V> coalescer) {
            this.coalescer = Objects.requireNonNull(coalescer);
            return this;
        }

        /** Returns a {@link CacheWriter} that batches writes to the system of record. */
        public RxCacheWriter<K, V> build() {
            return new RxCacheWriter<>(this);
        }
    }
}